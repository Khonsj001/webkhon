<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Learning Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/python/python.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/material.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/idea.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        python: {
                            blue: '#306998',
                            yellow: '#FFD43B',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .CodeMirror {
            height: auto;
            font-size: 16px;
            border-radius: 0.375rem;
        }
        
        .dark .CodeMirror.cm-s-idea {
            display: none;
        }
        
        .CodeMirror.cm-s-material {
            display: none;
        }
        
        .dark .CodeMirror.cm-s-material {
            display: block;
        }
        
        /* Transition animations */
        .fade-enter {
            opacity: 0;
            transform: translateY(20px);
        }
        
        .fade-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 300ms, transform 300ms;
        }
        
        /* Python syntax highlighting */
        .python-keyword {
            color: #306998;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="mb-8">
            <div class="flex justify-between items-center">
                <h1 class="text-3xl font-bold text-python-blue dark:text-python-yellow">Python Learning Platform</h1>
                <button id="theme-toggle" class="p-2 rounded-full bg-gray-200 dark:bg-gray-700">
                    <svg id="light-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 dark:hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                    </svg>
                    <svg id="dark-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden dark:block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                    </svg>
                </button>
            </div>
            <p class="mt-2 text-gray-600 dark:text-gray-300">Learn Python from beginner to advanced</p>
        </header>
        
        <nav class="mb-8">
            <div class="flex flex-wrap gap-2">
                <button class="level-btn px-4 py-2 rounded-lg bg-python-blue text-white font-medium active" data-level="beginner">Beginner</button>
                <button class="level-btn px-4 py-2 rounded-lg bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-200 font-medium" data-level="intermediate">Intermediate</button>
                <button class="level-btn px-4 py-2 rounded-lg bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-200 font-medium" data-level="advanced">Advanced</button>
            </div>
        </nav>
        
        <div id="topics-container" class="mb-8 grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- Topic buttons will be populated here -->
        </div>
        
        <div id="tutorial-container" class="mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 id="tutorial-title" class="text-2xl font-bold text-python-blue dark:text-python-yellow"></h2>
                <button id="back-btn" class="px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 font-medium">Back to Topics</button>
            </div>
            
            <div id="tutorial-content" class="prose dark:prose-invert max-w-none mb-6"></div>
            
            <div id="code-section" class="mb-6">
                <h3 class="text-xl font-bold mb-2">Try it yourself:</h3>
                <div id="code-editor" class="mb-4"></div>
                <div class="flex gap-4">
                    <button id="run-btn" class="px-4 py-2 rounded-lg bg-python-blue text-white font-medium">Run Code</button>
                    <button id="reset-btn" class="px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 font-medium">Reset Code</button>
                </div>
            </div>
            
            <div id="output-section" class="mb-6">
                <h3 class="text-xl font-bold mb-2">Output:</h3>
                <div id="output" class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 min-h-[100px] whitespace-pre-wrap font-mono"></div>
            </div>
        </div>
        
        <div id="loading" class="hidden">
            <div class="flex justify-center items-center py-12">
                <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-python-blue dark:border-python-yellow"></div>
            </div>
            <p class="text-center text-gray-600 dark:text-gray-400">Loading content...</p>
        </div>
        
        <div id="run-python-button" class="fixed bottom-4 right-4">
            <button id="ask-ai-btn" class="px-4 py-2 rounded-lg bg-python-blue text-white font-medium shadow-lg hover:shadow-xl transition-shadow">
                Ask AI about Python
            </button>
        </div>
    </div>

    <script>
        // Setup dark mode detection and toggle
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
        
        document.getElementById('theme-toggle').addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
        });
        
        // Tutorial data
        const tutorials = {
            beginner: [
                {
                    id: 'variables',
                    title: 'Variables and Data Types',
                    content: `
# Variables and Data Types

In Python, variables are created when you assign a value to them. Python is dynamically typed, which means you don't need to declare the variable type.

## Basic Data Types

- **Integer**: Whole numbers like \`5\`, \`100\`, \`-10\`
- **Float**: Decimal numbers like \`3.14\`, \`-0.001\`
- **String**: Text enclosed in quotes like \`"Hello"\` or \`'World'\`
- **Boolean**: \`True\` or \`False\`
- **None**: Represents the absence of a value
- **List**: Ordered collection of items \`[1, 2, 3]\`
- **Tuple**: Immutable ordered collection \`(1, 2, 3)\`
- **Dictionary**: Key-value pairs \`{"name": "John", "age": 30}\`
- **Set**: Unordered collection of unique items \`{1, 2, 3}\`

## Examples:
                    `,
                    code: `# Variable assignment
name = "John"
age = 30
is_employed = True

# You can change the value and type of a variable
name = "John Doe"  # Changed value
age = "Thirty"     # Changed type from int to string

# Different data types
integer_num = 42           # Integer
float_num = 3.14           # Float
text = "Hello, World!"     # String
boolean = False            # Boolean
nothing = None             # None
numbers = [1, 2, 3, 4]     # List
coordinates = (10, 20)     # Tuple
person = {                 # Dictionary
    "name": "Jane",
    "age": 25
}
unique_numbers = {1, 2, 3} # Set

# Output to console
print("String:", text)
print("Integer:", integer_num)
print("Float:", float_num)
print("Boolean:", boolean)
print("None:", nothing)
print("List:", numbers)
print("Tuple:", coordinates)
print("Dictionary:", person)
print("Set:", unique_numbers)

# Type checking
print("Type of name:", type(name))
print("Type of age:", type(age))
print("Type of numbers:", type(numbers))

# Using variables in strings
print(name + " is " + age)
# Modern way with f-strings (Python 3.6+)
print(f"{name} is {age}")

# Multi-assignment
x, y, z = 1, 2, 3
print(f"x={x}, y={y}, z={z}")`
                },
                {
                    id: 'operators',
                    title: 'Operators and Expressions',
                    content: `
# Operators and Expressions

Python provides various operators to perform operations on variables and values.

## Arithmetic Operators
- Addition: \`+\`
- Subtraction: \`-\`
- Multiplication: \`*\`
- Division: \`/\` (always returns a float)
- Integer Division: \`//\` (returns the quotient without the remainder)
- Modulus: \`%\` (returns the remainder)
- Exponentiation: \`**\`

## Comparison Operators
- Equal to: \`==\`
- Not equal to: \`!=\`
- Greater than: \`>\`
- Less than: \`<\`
- Greater than or equal to: \`>=\`
- Less than or equal to: \`<=\`

## Logical Operators
- AND: \`and\`
- OR: \`or\`
- NOT: \`not\`

## Assignment Operators
- Assign: \`=\`
- Add and assign: \`+=\`
- Subtract and assign: \`-=\`
- And more: \`*=\`, \`/=\`, \`%=\`, \`**=\`, \`//=\`

## Examples:
                    `,
                    code: `# Arithmetic operators
a = 10
b = 3

print("Addition:", a + b)           # 13
print("Subtraction:", a - b)        # 7
print("Multiplication:", a * b)     # 30
print("Division:", a / b)           # 3.3333...
print("Integer Division:", a // b)  # 3
print("Modulus:", a % b)            # 1
print("Exponentiation:", a ** b)    # 1000

# Comparison operators
x = 5
y = 10

print("x == y:", x == y)  # False
print("x != y:", x != y)  # True
print("x > y:", x > y)    # False
print("x < y:", x < y)    # True
print("x >= y:", x >= y)  # False
print("x <= y:", x <= y)  # True

# Logical operators
sunny = True
warm = False

print("sunny and warm:", sunny and warm)  # False
print("sunny or warm:", sunny or warm)    # True
print("not sunny:", not sunny)            # False

# Assignment operators
count = 0
print("Initial count:", count)

count += 5  # Same as: count = count + 5
print("After += 5:", count)

count -= 2  # Same as: count = count - 2
print("After -= 2:", count)

count *= 3  # Same as: count = count * 3
print("After *= 3:", count)

count //= 2  # Same as: count = count // 2
print("After //= 2:", count)

# Chained comparisons
age = 25
print("Is age between 18 and 30:", 18 <= age <= 30)  # True

# String operations
first_name = "John"
last_name = "Doe"

# String concatenation with +
full_name = first_name + " " + last_name
print("Full name:", full_name)

# String repetition with *
print("Ha" * 3)  # HaHaHa

# Membership operators
print("'J' in first_name:", 'J' in first_name)    # True
print("'x' not in last_name:", 'x' not in last_name)  # True

# Identity operators
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1

print("list1 is list2:", list1 is list2)  # False (different objects)
print("list1 is list3:", list1 is list3)  # True (same object)
print("list1 == list2:", list1 == list2)  # True (same values)`
                },
                {
                    id: 'control_flow',
                    title: 'Control Flow Statements',
                    content: `
# Control Flow Statements

Control flow statements determine the order in which code is executed based on certain conditions.

## if-elif-else Statement
Used for making decisions based on conditions.

## for Loop
Used for iterating over a sequence (like a list, tuple, string, etc.).

## while Loop
Used to execute a block of code as long as a condition is true.

## break and continue
- \`break\`: Exits the loop immediately
- \`continue\`: Skips the current iteration and continues with the next

## Examples:
                    `,
                    code: `# if-elif-else statement
temperature = 25

if temperature > 30:
    print("It's hot outside!")
elif temperature > 20:
    print("It's a nice day!")
elif temperature > 10:
    print("It's a bit cold.")
else:
    print("It's cold outside!")

# Nested if statements
is_weekend = True
is_sunny = True

if is_weekend:
    if is_sunny:
        print("Let's go to the beach!")
    else:
        print("Let's watch a movie at home.")
else:
    print("Let's go to work.")

# for loop with a list
fruits = ["apple", "banana", "orange"]

for fruit in fruits:
    print(f"I like {fruit}s")

# for loop with range
print("Numbers from 0 to 4:")
for i in range(5):  # 0, 1, 2, 3, 4
    print(i, end=" ")
print()  # Newline

print("Numbers from 1 to 10, step 2:")
for i in range(1, 11, 2):  # 1, 3, 5, 7, 9
    print(i, end=" ")
print()  # Newline

# while loop
count = 0
while count < 5:
    print(f"Count is {count}")
    count += 1

# break statement
print("Using break:")
for i in range(10):
    if i == 5:
        print("Breaking the loop at i =", i)
        break
    print(i, end=" ")
print()  # Newline

# continue statement
print("Using continue:")
for i in range(10):
    if i % 2 == 0:  # Skip even numbers
        continue
    print(i, end=" ")  # Print only odd numbers
print()  # Newline

# Looping through a string
for char in "Python":
    print(char, end="-")
print()  # Newline

# Looping through a dictionary
person = {"name": "John", "age": 30, "city": "New York"}

print("Dictionary keys:")
for key in person:
    print(key, end=" ")
print()  # Newline

print("Dictionary values:")
for value in person.values():
    print(value, end=" ")
print()  # Newline

print("Dictionary items:")
for key, value in person.items():
    print(f"{key}: {value}")`
                }
            ],
            intermediate: [
                {
                    id: 'functions',
                    title: 'Functions',
                    content: `
# Functions

Functions are blocks of reusable code designed to perform a specific task. They help organize code, promote reusability, and make the code more readable.

## Defining Functions
Functions are defined using the \`def\` keyword, followed by the function name and parameters.

## Parameters and Arguments
- **Parameters**: Names listed in the function definition
- **Arguments**: Values passed to the function when calling it

## Return Statement
Functions can return values using the \`return\` statement.

## Default Parameters
Parameters can have default values.

## Arbitrary Arguments
Functions can accept a variable number of arguments using \`*args\` and \`**kwargs\`.

## Examples:
                    `,
                    code: `# Basic function definition
def greet(name):
    """This function greets the person passed in as a parameter"""
    return f"Hello, {name}!"

# Calling the function
message = greet("John")
print(message)  # Hello, John!

# Function with multiple parameters
def add(a, b):
    return a + b

result = add(5, 3)
print(f"5 + 3 = {result}")

# Function with default parameter
def greet_with_message(name, message="Good day"):
    return f"{message}, {name}!"

print(greet_with_message("Alice"))  # Good day, Alice!
print(greet_with_message("Bob", "Welcome"))  # Welcome, Bob!

# Function with arbitrary arguments (*args)
def sum_all(*numbers):
    """Sum all numbers passed to the function"""
    total = 0
    for num in numbers:
        total += num
    return total

print(sum_all(1, 2, 3, 4, 5))  # 15
print(sum_all(10, 20))         # 30

# Function with keyword arguments (**kwargs)
def print_person_info(**kwargs):
    """Print all keyword arguments"""
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_person_info(name="John", age=30, city="New York")

# Lambda functions (anonymous functions)
square = lambda x: x ** 2
print(f"Square of 5: {square(5)}")  # 25

# Using lambda with map
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x ** 2, numbers))
print(f"Squared numbers: {squared_numbers}")  # [1, 4, 9, 16, 25]

# Using lambda with filter
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(f"Even numbers: {even_numbers}")  # [2, 4]

# Nested functions
def outer_function(x):
    """Outer function"""
    def inner_function(y):
        """Inner function"""
        return x + y
    
    return inner_function

add_five = outer_function(5)
print(add_five(3))  # 8

# Docstrings
def multiply(a, b):
    """
    Multiply two numbers and return the result.
    
    Parameters:
    a (int): The first number
    b (int): The second number
    
    Returns:
    int: The product of a and b
    """
    return a * b

# Access the docstring
print(multiply.__doc__)`
                },
                {
                    id: 'data_structures',
                    title: 'Data Structures',
                    content: `
# Data Structures

Python has several built-in data structures that help organize and manipulate data efficiently.

## Lists
Ordered, mutable collections of items.

## Tuples
Ordered, immutable collections of items.

## Dictionaries
Unordered collections of key-value pairs.

## Sets
Unordered collections of unique items.

## List Comprehensions
Concise way to create lists based on existing lists.

## Examples:
                    `,
                    code: `# ----------------------
# Lists
# ----------------------
fruits = ["apple", "banana", "orange", "mango"]
print("Original list:", fruits)

# Accessing items
print("First fruit:", fruits[0])  # apple
print("Last fruit:", fruits[-1])  # mango
print("Slicing:", fruits[1:3])    # ['banana', 'orange']

# Modifying lists
fruits.append("pineapple")  # Add to the end
print("After append:", fruits)

fruits.insert(1, "grape")   # Insert at position 1
print("After insert:", fruits)

fruits.remove("banana")     # Remove specific item
print("After remove:", fruits)

popped = fruits.pop()       # Remove and return the last item
print("Popped item:", popped)
print("After pop:", fruits)

fruits.sort()               # Sort in place
print("After sort:", fruits)

fruits.reverse()            # Reverse in place
print("After reverse:", fruits)

# List comprehensions
numbers = [1, 2, 3, 4, 5]
squared = [x**2 for x in numbers]
print("Squared numbers:", squared)

even_squares = [x**2 for x in numbers if x % 2 == 0]
print("Squares of even numbers:", even_squares)

# ----------------------
# Tuples
# ----------------------
coordinates = (10, 20)
print("Tuple:", coordinates)

# Tuple unpacking
x, y = coordinates
print(f"Coordinates: x={x}, y={y}")

# Tuples are immutable
# coordinates[0] = 15  # This would raise an error

# Multiple returns with tuples
def get_min_max(numbers):
    return min(numbers), max(numbers)

minimum, maximum = get_min_max([3, 1, 5, 2, 4])
print(f"Min: {minimum}, Max: {maximum}")

# ----------------------
# Dictionaries
# ----------------------
person = {
    "name": "John",
    "age": 30,
    "city": "New York"
}
print("Dictionary:", person)

# Accessing items
print("Name:", person["name"])
print("Age:", person.get("age"))
print("Job:", person.get("job", "Not specified"))  # Default if key not found

# Modifying dictionaries
person["email"] = "john@example.com"  # Add new key-value pair
print("After adding email:", person)

person["age"] = 31  # Modify existing value
print("After changing age:", person)

del person["city"]  # Remove a key-value pair
print("After deleting city:", person)

# Dictionary methods
print("Keys:", list(person.keys()))
print("Values:", list(person.values()))
print("Items:", list(person.items()))

# Dictionary comprehension
squares_dict = {x: x**2 for x in range(1, 6)}
print("Dictionary comprehension:", squares_dict)

# ----------------------
# Sets
# ----------------------
fruits_set = {"apple", "banana", "orange", "apple"}  # Duplicates removed
print("Set:", fruits_set)

# Set operations
fruits_set.add("grape")
print("After adding grape:", fruits_set)

fruits_set.remove("banana")
print("After removing banana:", fruits_set)

# Set operations with multiple sets
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

print("Union:", set1 | set2)         # All elements from both sets
print("Intersection:", set1 & set2)  # Elements common to both sets
print("Difference:", set1 - set2)    # Elements in set1 but not in set2
print("Symmetric difference:", set1 ^ set2)  # Elements in either set but not both

# Set comprehension
even_set = {x for x in range(10) if x % 2 == 0}
print("Set comprehension:", even_set)`
                },
                {
                    id: 'file_handling',
                    title: 'File Handling',
                    content: `
# File Handling

Python provides built-in functions to create, read, write, and manipulate files.

## Opening Files
The \`open()\` function is used to open files with different modes:
- \`'r'\`: Read (default)
- \`'w'\`: Write (creates new file or truncates existing file)
- \`'a'\`: Append (adds to the end of the file)
- \`'b'\`: Binary mode
- \`'t'\`: Text mode (default)

## Reading Files
Methods to read file content:
- \`read()\`: Reads the entire file
- \`readline()\`: Reads a single line
- \`readlines()\`: Reads all lines into a list

## Writing Files
Methods to write to files:
- \`write()\`: Writes a string to the file
- \`writelines()\`: Writes a list of strings to the file

## Context Manager (with statement)
The recommended way to work with files using the \`with\` statement.

## Examples:
                    `,
                    code: `# Since we can't actually create files in this environment,
# we'll simulate file operations using StringIO

from io import StringIO

# Simulate a file with some initial content
file_content = """This is line 1
This is line 2
This is line 3
"""

# Create a StringIO object (simulates a file)
file = StringIO(file_content)

# ----------------------
# Reading Files
# ----------------------

# Reading the entire file
file.seek(0)  # Go to the beginning of the file
content = file.read()
print("Reading entire file:")
print(content)

# Reading line by line
file.seek(0)  # Go to the beginning of the file
print("Reading line by line:")
line = file.readline()
while line:
    print(line.strip())  # strip() removes the newline character
    line = file.readline()

# Reading all lines into a list
file.seek(0)  # Go to the beginning of the file
lines = file.readlines()
print("All lines as a list:")
print(lines)

# Iterating through lines
file.seek(0)  # Go to the beginning of the file
print("Iterating through lines:")
for line in file:
    print(line.strip())

# ----------------------
# Writing Files
# ----------------------

# Create a new simulated file for writing
output_file = StringIO()

# Writing a single line
output_file.write("This is a new line.\n")

# Writing multiple lines
lines_to_write = ["Line 1\n", "Line 2\n", "Line 3\n"]
output_file.writelines(lines_to_write)

# Reading what we've written
output_file.seek(0)  # Go to the beginning of the file
print("Content of the written file:")
print(output_file.read())

# ----------------------
# Using with statement (context manager)
# ----------------------

# In a real Python environment, you would use:
"""
# Writing to a file
with open('example.txt', 'w') as file:
    file.write('Hello, World!')
    file.write('This is a new line.')

# Reading from a file
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
"""

# Simulating the with statement behavior
print("Using context manager (simulated):")
output_file = StringIO()
output_file.write("Line written with context manager.\n")
output_file.seek(0)
print(output_file.read())

# ----------------------
# Working with binary files (simulated)
# ----------------------

print("Binary file operations (simulated):")
"""
# In a real Python environment, binary files would be handled like:
with open('image.jpg', 'rb') as binary_file:
    binary_data = binary_file.read(10)  # Read first 10 bytes
    print(binary_data)

with open('new_image.jpg', 'wb') as binary_file:
    binary_file.write(binary_data)
"""

# ----------------------
# File and Directory Operations
# ----------------------

print("File and Directory Operations:")
"""
# In a real Python environment:
import os

# List files in a directory
files = os.listdir('.')
print(files)

# Check if a file exists
if os.path.exists('example.txt'):
    print('File exists')

# Get file information
file_size = os.path.getsize('example.txt')
print(f'File size: {file_size} bytes')

# Create a directory
os.mkdir('new_directory')

# Delete a file
os.remove('old_file.txt')
"""

# Close the simulated files
file.close()
output_file.close()`
                }
            ],
            advanced: [
                {
                    id: 'modules_packages',
                    title: 'Modules and Packages',
                    content: `
# Modules and Packages

Python's modular approach allows code organization into separate files (modules) and directories (packages).

## Modules
A module is a file containing Python code. The module name is the filename without the .py extension.

## Packages
A package is a directory that contains multiple modules and a special \`__init__.py\` file.

## Importing
Different ways to import modules and packages in Python.

## Creating Your Own Modules
How to create your own modules and packages.

## Popular Standard Library Modules
Python comes with a rich standard library.

## Examples:
                    `,
                    code: `# Importing standard library modules
import math
import random
import datetime
import os
import sys

# Using the math module
print("Pi:", math.pi)
print("Square root of 16:", math.sqrt(16))
print("Cosine of 0:", math.cos(0))

# Using the random module
print("Random number between 0 and 1:", random.random())
print("Random integer between 1 and 10:", random.randint(1, 10))
random_choice = random.choice(["apple", "banana", "orange"])
print("Random choice from list:", random_choice)

# Using the datetime module
now = datetime.datetime.now()
print("Current date and time:", now)
print("Formatted date:", now.strftime("%Y-%m-%d"))
print("Day of the week:", now.strftime("%A"))

# Different import styles
from math import sqrt, pow
print("Using imported functions directly:")
print("Square root of 25:", sqrt(25))
print("2 to the power of 3:", pow(2, 3))

# Import with alias
import math as m
print("Using alias:")
print("Pi using alias:", m.pi)

# Import all names (not recommended)
# from math import *

# ----------------------
# Creating a simulated module
# ----------------------
print("Simulating a custom module:")

# Simulating a module 'mymodule.py'
class SimulatedModule:
    def greet(self, name):
        return f"Hello, {name}!"
    
    def add(self, a, b):
        return a + b
    
    VERSION = "1.0.0"

# Using the simulated module
mymodule = SimulatedModule()
print(mymodule.greet("Alice"))
print(f"3 + 5 = {mymodule.add(3, 5)}")
print(f"Module version: {mymodule.VERSION}")

# ----------------------
# Simulating package structure
# ----------------------
print("Simulating a package structure:")

"""
In a real Python project, the directory structure might look like:

mypackage/
    __init__.py
    module1.py
    module2.py
    subpackage/
        __init__.py
        module3.py

Then you could import it like:
import mypackage.module1
from mypackage import module2
from mypackage.subpackage import module3
"""

# ----------------------
# Module search path
# ----------------------
print("Module search paths:")
for path in sys.path:
    print(path)

# ----------------------
# Common standard library modules
# ----------------------
print("\nDemonstrating other standard library modules:")

# os module for operating system functionality
print("Current working directory:", os.getcwd())
# print("List directory:", os.listdir("."))

# sys module for system-specific parameters and functions
print("Python version:", sys.version)
print("Platform:", sys.platform)

# Built-in dir() function
print("\nFunctions and attributes in the math module:")
math_attributes = [attr for attr in dir(math) if not attr.startswith("_")]
print(math_attributes[:10])  # Show first 10 for brevity

# The if __name__ == "__main__" idiom
print("\nUsing the '__main__' idiom:")
if __name__ == "__main__":
    print("This code runs only when the file is executed directly")

# Simulating module execution
def simulate_module_execution():
    name = "__main__"  # Simulating direct execution
    if name == "__main__":
        print("Module executed directly!")
    else:
        print("Module imported, not executed directly")

simulate_module_execution()`
                },
                {
                    id: 'oop',
                    title: 'Object-Oriented Programming',
                    content: `
# Object-Oriented Programming

Python is a multi-paradigm language that supports object-oriented programming (OOP). OOP is a programming paradigm based on the concept of "objects" that contain data and code.

## Classes and Objects
A class is a blueprint for creating objects. An object is an instance of a class.

## Attributes and Methods
Classes can have attributes (data) and methods (functions).

## Inheritance
A class can inherit attributes and methods from another class.

## Encapsulation
Restricting access to methods and variables to prevent direct data modification.

## Polymorphism
The ability to present the same interface for different data types.

## Examples:
                    `,
                    code: `# ----------------------
# Classes and Objects
# ----------------------

# Defining a simple class
class Person:
    # Class attribute (shared by all instances)
    species = "Homo sapiens"
    
    # Constructor method
    def __init__(self, name, age):
        # Instance attributes (unique to each instance)
        self.name = name
        self.age = age
    
    # Instance method
    def greet(self):
        return f"Hello, my name is {self.name}."
    
    # Instance method with parameters
    def celebrate_birthday(self):
        self.age += 1
        return f"{self.name} is now {self.age} years old!"
    
    # String representation
    def __str__(self):
        return f"Person(name={self.name}, age={self.age})"
    
    # Representation (for debugging)
    def __repr__(self):
        return f"Person('{self.name}', {self.age})"

# Creating objects (instances)
person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

print(person1.name)   # Accessing attributes
print(person2.age)
print(person1.greet())  # Calling methods
print(person2.celebrate_birthday())

# Accessing class attributes
print(f"Species: {Person.species}")
print(f"{person1.name} is a {person1.species}")

# String representation
print(person1)  # Calls __str__
print(repr(person2))  # Calls __repr__

# ----------------------
# Inheritance
# ----------------------
class Employee(Person):  # Employee inherits from Person
    # Constructor method
    def __init__(self, name, age, employee_id, salary):
        # Call parent class constructor
        super().__init__(name, age)
        # Additional attributes
        self.employee_id = employee_id
        self.salary = salary
    
    # Override the greet method
    def greet(self):
        return f"Hello, I'm {self.name}, employee #{self.employee_id}."
    
    # New method specific to Employee
    def get_salary_info(self):
        return f"{self.name}'s salary is ${self.salary}."

# Create an Employee instance
employee = Employee("Charlie", 35, "E12345", 50000)

# Using inherited and overridden methods
print(employee.greet())  # Uses Employee's greet method
print(employee.celebrate_birthday())  # Uses Person's method
print(employee.get_salary_info())  # Uses Employee's method

# Checking inheritance
print(f"Is employee an Employee? {isinstance(employee, Employee)}")
print(f"Is employee a Person? {isinstance(employee, Person)}")

# ----------------------
# Encapsulation
# ----------------------
class BankAccount:
    def __init__(self, account_number, balance):
        self.account_number = account_number
        self._balance = balance  # Protected attribute (convention)
        self.__secret_pin = "1234"  # Private attribute (name mangling)
    
    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
            return f"Deposited ${amount}. New balance: ${self._balance}"
        return "Invalid amount"
    
    def withdraw(self, amount):
        if 0 < amount <= self._balance:
            self._balance -= amount
            return f"Withdrew ${amount}. New balance: ${self._balance}"
        return "Invalid amount or insufficient funds"
    
    def get_balance(self):
        return f"Current balance: ${self._balance}"
    
    # Private method
    def __validate_pin(self, pin):
        return pin == self.__secret_pin
    
    # Method to access private method
    def authorize(self, pin):
        if self.__validate_pin(pin):
            return "Authorization successful"
        return "Invalid PIN"

# Create a bank account
account = BankAccount("12345", 1000)

print(account.get_balance())
print(account.deposit(500))
print(account.withdraw(200))
print(account.authorize("1234"))

# Accessing protected attribute (possible but discouraged)
print(f"Protected balance: {account._balance}")

# Trying to access private attribute (name mangling)
# print(account.__secret_pin)  # This would raise an AttributeError
# But we can still access it through its mangled name
print(f"Private PIN (through mangling): {account._BankAccount__secret_pin}")

# ----------------------
# Polymorphism
# ----------------------
class Animal:
    def speak(self):
        return "Some sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class Duck(Animal):
    def speak(self):
        return "Quack!"

# Function that can work with any Animal
def animal_sound(animal):
    return animal.speak()

# Create different animals
dog = Dog()
cat = Cat()
duck = Duck()

# Polymorphic behavior
print(animal_sound(dog))
print(animal_sound(cat))
print(animal_sound(duck))

# Example with built-in polymorphism
print(len("Hello"))  # String length
print(len([1, 2, 3]))  # List length
print(len({"a": 1, "b": 2}))  # Dictionary length

# ----------------------
# Class methods and static methods
# ----------------------
class MathUtils:
    # Class variable
    pi = 3.14159
    
    # Regular instance method
    def add(self, a, b):
        return a + b
    
    # Class method (operates on the class itself)
    @classmethod
    def get_pi(cls):
        return cls.pi
    
    # Static method (doesn't need class or instance)
    @staticmethod
    def multiply(a, b):
        return a * b

# Using class and static methods without creating an instance
print(f"Pi: {MathUtils.get_pi()}")
print(f"5 × 3 = {MathUtils.multiply(5, 3)}")

# Create an instance to use the instance method
math = MathUtils()
print(f"5 + 3 = {math.add(5, 3)}")

# But class and static methods are also available on instances
print(f"Pi from instance: {math.get_pi()}")
print(f"4 × 2 from instance: {math.multiply(4, 2)}")`
                },
                {
                    id: 'decorators_generators',
                    title: 'Decorators and Generators',
                    content: `
# Decorators and Generators

Decorators and generators are advanced Python features that provide elegant solutions to common programming challenges.

## Decorators
Decorators modify the behavior of functions or methods without changing their code.

## Generators
Generators are functions that return an iterator that yields values one at a time.

## Context Managers
Context managers provide setup and cleanup actions around a block of code.

## Examples:
                    `,
                    code: `# ----------------------
# Decorators
# ----------------------

# Define a simple decorator
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()  # Call the original function
        print("Something is happening after the function is called.")
    return wrapper

# Apply the decorator to a function
@my_decorator
def say_hello():
    print("Hello!")

# Call the decorated function
print("Calling the decorated function:")
say_hello()

# Decorator with arguments
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print(f"Function called with arguments: {args} and keyword arguments: {kwargs}")
        result = func(*args, **kwargs)
        print(f"Function returned: {result}")
        return result
    return wrapper

@decorator_with_args
def add(a, b):
    return a + b

print("\nCalling function with decorator that handles arguments:")
result = add(5, 3)
print(f"Result: {result}")

# Decorator that takes parameters
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(n):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    return f"Hello, {name}!"

print("\nCalling function with parameterized decorator:")
results = greet("World")
for result in results:
    print(result)

# ----------------------
# Timers with decorators
# ----------------------
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Function {func.__name__} took {end_time - start_time:.4f} seconds to run")
        return result
    return wrapper

@timer
def slow_function():
    # Simulate a slow function
    time.sleep(1)
    return "Function completed"

print("\nTiming a function with a decorator:")
slow_function()

# ----------------------
# Generators
# ----------------------
print("\nSimple generator:")

def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

# Using the generator
counter = count_up_to(5)
print(next(counter))  # 1
print(next(counter))  # 2
print(next(counter))  # 3
print(next(counter))  # 4
print(next(counter))  # 5
# print(next(counter))  # StopIteration error

# Using a generator in a for loop
print("\nIterating through a generator:")
for number in count_up_to(3):
    print(number)

# Generator expression (similar to list comprehension)
print("\nGenerator expression:")
squares_gen = (x**2 for x in range(1, 6))
for square in squares_gen:
    print(square)

# Infinite generator
def infinite_counter():
    count = 0
    while True:
        count += 1
        yield count

print("\nInfinite generator (taking first 5 values):")
counter = infinite_counter()
for _ in range(5):
    print(next(counter))

# Generator with send
def echo_generator():
    while True:
        received = yield
        print(f"Received: {received}")

print("\nGenerator with send:")
echo = echo_generator()
next(echo)  # Prime the generator
echo.send("Hello")
echo.send("World")

# ----------------------
# Context Managers
# ----------------------
print("\nUsing a context manager:")

# Context manager using a class
class FileSimulator:
    def __init__(self, filename):
        self.filename = filename
        self.file = None
    
    def __enter__(self):
        print(f"Opening file {self.filename}")
        self.file = f"Simulated file {self.filename}"
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Closing file {self.filename}")
        self.file = None

# Using the context manager
with FileSimulator("example.txt") as file:
    print(f"Working with {file}")

# Context manager using contextlib
from contextlib import contextmanager

@contextmanager
def timer_context():
    start_time = time.time()
    try:
        yield  # This is where the with-block code executes
    finally:
        end_time = time.time()
        print(f"Code took {end_time - start_time:.4f} seconds to run")

# Using the contextlib context manager
with timer_context():
    # Simulate some work
    time.sleep(0.5)
    print("Doing some work...")

# ----------------------
# Combining decorators and generators
# ----------------------
print("\nCombining decorators and generators:")

@timer
def generate_large_list():
    return [i for i in range(1000000)]

@timer
def generate_with_generator():
    return list(i for i in range(1000000))

print("Creating a large list with list comprehension:")
large_list = generate_large_list()
print(f"List size: {len(large_list)}")

print("\nCreating a large list with generator expression:")
from_generator = generate_with_generator()
print(f"List size: {len(from_generator)}")`
                }
            ]
        };
        
        // Initialize CodeMirror editor
        let codeEditor;
        let currentCode = "";
        let originalCode = "";
        
        function initCodeEditor(code) {
            if (codeEditor) {
                codeEditor.toTextArea(); // Destroy old instance
            }
            
            originalCode = code;
            currentCode = code;
            
            const editorElement = document.getElementById('code-editor');
            const textArea = document.createElement('textarea');
            editorElement.innerHTML = '';
            editorElement.appendChild(textArea);
            textArea.value = code;
            
            codeEditor = CodeMirror.fromTextArea(textArea, {
                mode: "python",
                theme: document.documentElement.classList.contains('dark') ? "material" : "idea",
                lineNumbers: true,
                tabSize: 4,
                indentWithTabs: false,
                indentUnit: 4,
                smartIndent: true,
                autoCloseBrackets: true,
                matchBrackets: true
            });
            
            // Create duplicate editors for light/dark mode
            const lightEditor = codeEditor.getWrapperElement().cloneNode(true);
            lightEditor.classList.add('cm-s-idea');
            lightEditor.classList.remove('cm-s-material');
            editorElement.appendChild(lightEditor);
            
            // Make sure light/dark editors stay in sync
            codeEditor.on('change', (cm) => {
                currentCode = cm.getValue();
                const otherEditor = editorElement.querySelector('.CodeMirror:not(.cm-s-' + cm.getOption('theme') + ')');
                if (otherEditor) {
                    const otherCM = otherEditor.CodeMirror;
                    if (otherCM && otherCM.getValue() !== currentCode) {
                        otherCM.setValue(currentCode);
                    }
                }
            });
        }
        
        // Run the code through Poe AI
        async function runCode() {
            const outputElement = document.getElementById('output');
            outputElement.textContent = "Running code...";
            
            try {
                // Here we would normally send the Python code to be executed
                // Since we can't actually run Python in the browser, we'll use Poe API to do it
                await window.Poe.sendUserMessage(
                    "@Claude-3.7-Sonnet Please execute this Python code and show only the output: \n```python\n" + currentCode + "\n```",
                    {
                        handler: "python-runner",
                        stream: true,
                        openChat: false
                    }
                );
            } catch (error) {
                outputElement.textContent = "Error: " + error.message;
            }
        }
        
        // Poe handler for Python execution results
        window.Poe.registerHandler("python-runner", (result) => {
            const outputElement = document.getElementById('output');
            const response = result.responses[0];
            
            if (response.status === "error") {
                outputElement.textContent = "Error: " + response.statusText;
            } else if (response.status === "incomplete") {
                // Parse the partial code execution response
                const content = response.content;
                const output = extractCodeOutput(content);
                outputElement.textContent = output;
            } else if (response.status === "complete") {
                // Parse the complete code execution response
                const content = response.content;
                const output = extractCodeOutput(content);
                outputElement.textContent = output;
            }
        });
        
        // Extract code output from Claude's response
        function extractCodeOutput(content) {
            // Simplistic parsing - try to extract content between code blocks or after "Output:" markers
            let output = content;
            
            // Remove markdown formatting and explanations
            if (output.includes("```")) {
                const codeBlocks = output.split("```");
                // Usually the output is in the second code block if there are multiple
                if (codeBlocks.length >= 3) {
                    output = codeBlocks[2].trim();
                }
            }
            
            // Look for "Output:" markers
            if (output.includes("Output:")) {
                output = output.split("Output:")[1].trim();
            }
            
            // Remove explanations before the actual output
            if (output.includes("\n\n")) {
                const parts = output.split("\n\n");
                output = parts[parts.length - 1].trim();
            }
            
            return output;
        }
        
        // Reset the code editor to original code
        function resetCode() {
            if (codeEditor) {
                codeEditor.setValue(originalCode);
                document.getElementById('output').textContent = "";
            }
        }
        
        // Show topics for a specific level
        function showTopics(level) {
            const topicsContainer = document.getElementById('topics-container');
            topicsContainer.innerHTML = ''; // Clear previous topics
            
            // Show topics container, hide tutorial container
            topicsContainer.classList.remove('hidden');
            document.getElementById('tutorial-container').classList.add('hidden');
            document.getElementById('loading').classList.add('hidden');
            
            // Update active level button
            document.querySelectorAll('.level-btn').forEach(btn => {
                if (btn.dataset.level === level) {
                    btn.classList.add('bg-python-blue', 'text-white');
                    btn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-200');
                } else {
                    btn.classList.remove('bg-python-blue', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-200');
                }
            });
            
            // Create topic buttons
            tutorials[level].forEach(topic => {
                const topicButton = document.createElement('button');
                topicButton.className = 'topic-btn p-4 rounded-lg bg-white dark:bg-gray-800 shadow hover:shadow-md transition-shadow border border-gray-200 dark:border-gray-700 text-left';
                topicButton.innerHTML = `
                    <h3 class="text-xl font-bold text-python-blue dark:text-python-yellow mb-2">${topic.title}</h3>
                    <p class="text-gray-600 dark:text-gray-300">${topic.content.split('\n')[0].replace('#', '').trim()}</p>
                `;
                topicButton.addEventListener('click', () => showTutorial(level, topic.id));
                topicsContainer.appendChild(topicButton);
                
                // Add fade-in animation
                setTimeout(() => {
                    topicButton.classList.add('fade-enter-active');
                }, 100);
            });
        }
        
        // Show a specific tutorial
        function showTutorial(level, topicId) {
            const topic = tutorials[level].find(t => t.id === topicId);
            if (!topic) return;
            
            // Show loading state
            document.getElementById('topics-container').classList.add('hidden');
            document.getElementById('tutorial-container').classList.add('hidden');
            document.getElementById('loading').classList.remove('hidden');
            
            // Delay to simulate loading and show the transition
            setTimeout(() => {
                document.getElementById('tutorial-title').textContent = topic.title;
                document.getElementById('tutorial-content').innerHTML = marked.parse(topic.content);
                
                // Initialize code editor with the topic's code
                initCodeEditor(topic.code);
                
                // Show tutorial container, hide topics and loading
                document.getElementById('tutorial-container').classList.remove('hidden');
                document.getElementById('topics-container').classList.add('hidden');
                document.getElementById('loading').classList.add('hidden');
                
                // Clear output
                document.getElementById('output').textContent = "";
            }, 500);
        }
        
        // Handle AI questions
        async function askAI() {
            try {
                await window.Poe.sendUserMessage(
                    "@Claude-3.7-Sonnet I'm learning Python. Can you explain a Python concept to me? Please provide a short and clear explanation about a useful Python feature.",
                    { openChat: true }
                );
            } catch (error) {
                console.error("Error asking AI:", error);
            }
        }
        
        // Initialize the application
        function initApp() {
            // Event listeners for level buttons
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => showTopics(btn.dataset.level));
            });
            
            // Back button event listener
            document.getElementById('back-btn').addEventListener('click', () => {
                const activeLevel = document.querySelector('.level-btn.active').dataset.level;
                showTopics(activeLevel);
            });
            
            // Run and Reset buttons
            document.getElementById('run-btn').addEventListener('click', runCode);
            document.getElementById('reset-btn').addEventListener('click', resetCode);
            
            // Ask AI button
            document.getElementById('ask-ai-btn').addEventListener('click', askAI);
            
            // Show beginner topics by default
            showTopics('beginner');
            
            // Update active class when clicking level buttons
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });
        }
        
        // Start the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>